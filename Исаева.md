## Создать таблицы и задать связи, заполнить данными для следующих примеров:

### 1. Команды и сотрудники:
- команда может иметь несколько сотрудников
- сотрудник может работать только в одной команде
- команда - название, дата создания
- сотрудник - имя, фамилия, должность
- drop table if exists commands, employes cascade;

create table commands
(
	id int primary key,
	title text,
	date_create date
);
create table employes
(
	id int primary key,
	command_id int references commands,
	first_name text,
	last_name text,
	position_job text
);

insert into commands(id, title, date_create)
values
(1, 'command1', '2022-12-03'),
(2, 'command2', '2023-08-09'),
(3, 'command3', '2023-10-08'),
(4, 'command4', '2024-02-17');

insert into employes(id, command_id, first_name, last_name, position_job)
values
(1, 2, 'Name', 'Last_name', 'position1'),
(2, 3, 'Name2', 'Last_name2', 'position2'),
(3, 1, 'Name3', 'Lasy_name3', 'position3'),
(4, 3, 'Name4', 'Last_name4', 'position4'),
(5, 4, 'Name5', 'Last_name5', 'position5');

select 
	commands.id,
	title,
	date_create,
	coalesce(jsonb_agg(jsonb_build_object('id', employes.id, 'command_id', employes.command_id,
	'first_name', employes.first_name, 'last_name',
	employes.last_name, 'position_job', employes.position_job)) filter(where employes.id is not null), '[]') as employes
from commands
left join employes on commands.id = employes.command_id
group by commands.id;


### 2. Задачи и комментарии:
- задача может иметь несколько комментариев
- комментарий может принадлежать только одной задаче
- задача - название, описание, сложность
- комментарий - текст, дата публикации

- drop table if exists tasks, reviews cascade;

create table tasks
(
	id int primary key,
	title text,
	description text,
	level text
);

create table reviews
(
	id int primary key,
	task_id int references tasks,
	review_comment text,
	date_of_public date
);

insert into tasks(id, title, description, level)
values
(1, 'task1', 'dec1', 'hard'),
(2, 'task2', 'dec2', 'medium'),
(3, 'task3', 'dec3', 'light'),
(4, 'task4', 'dec4', 'medium');

insert into reviews(id, task_id, review_comment, date_of_public)
values
(1, 3, 'comment', '2024-01-13'),
(2, 4, 'comment2', '2023-05-20'),
(3, 4, 'comment3', '2023-07-15'),
(4, 1, 'comment4', '2021-09-12'),
(5, 2, 'comment5', '2024-03-08');

select 
	tasks.id,
	title,
	description,
	level,
	coalesce(jsonb_agg(jsonb_build_object('id', reviews.id, 'task_id', reviews.task_id,
	'review_comment', reviews.review_comment, 'date_of_public',
	reviews.date_of_public)) filter(where reviews.id is not null), '[]') as reviews
from tasks
left join reviews on tasks.id = reviews.task_id
group by tasks.id;

### 3. Покупатели и заказы:
 - покупатель может иметь несколько заказов
 - заказ принадлежит только одному покупателю
 - покупатель - имя, фамилия, телефон
 - заказ - дата, сумма

 - drop table if exists clients, orders cascade;
create table clients
(
	id int primary key,
	first_name text,
	last_name text,
	phone text
);
create table orders
(
	id int primary key,
	client_id int references clients,
	date_order date,
	total_price int
);

insert into clients(id, first_name, last_name, phone)
values
(1, 'name', 'last_name', '323242121'),
(2, 'name2', 'last_name2', '3422323324'),
(3, 'name3', 'last_name3', '940203232'),
(4, 'name4', 'last_name4', '3020413023');

insert into orders(id, client_id, date_order, total_price)
values
(1, 2, '2022-05-01', 3489),
(2, 4, '2023-09-18', 4789),
(3, 1, '2023-10-23', 28900),
(4, 3, '2024-01-12', 2324),
(5, 1, '2024-03-21', 5839);

select 
	clients.id,
	first_name,
	last_name,
	phone,
	coalesce(jsonb_agg(jsonb_build_object('id', orders.id, 'client_id', orders.client_id,
	'date_order', orders.date_order, 'total_price',
	orders.total_price)) filter(where orders.id is not null), '[]') as orders
from clients
left join orders on clients.id = orders.client_id
group by clients.id;



## Для каждого примера сделать вывод связанных сущностей (за один запрос)
- зависимая сущность должна быть представлена в виде массива объектов
- учесть случай когда на главную таблицу может не быть ссылок в строках зависимой таблицы
- если на строки из главной таблицы нет ссылок из зависимой таблицы, эти строки всё равно должны выводиться
- на одну из строк главной таблицы должно быть хотя бы 2 ссылки из зависимой таблицы
